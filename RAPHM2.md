# Milestone 2: Reverse Engineering Abstractions
Name: Raphael Bassot
Course: SENG350 - Software Architecture
Group: #2

# Part 1: Abstractions in the Reference System - Twisted
### Abstraction: Deferred Objects
One important abstraction that Twisted makes use of is the concept of a *Deferred* object to help organize the consequences that follow event-driven programming. A Deferred object is a type of abstraction that is in essence ["a promise that a function [returning a Deferred object] will return at some point"](http://aosabook.org/en/twisted.html). This abstraction's purpose revolves around the nature of callback functions - executables that are passed as arguments to a parent function that typically execute after the parent has completed its work. In event-driven programming, callbacks execute asynchronously, which means they can execute sometime later on, independently of other running code. The implementation of asynchronous callbacks is what allows Twisted to follow event-driven design. Event-driven programming involves a continuously-executing event loop that detects event triggers (termination). Completed events trigger callback functions, which describe how the event that just ended in an application should be handled (post-completion behaviour). Multiple events completing can result in a chain of callbacks being called, which can become confusing to follow for the developer. Deferred objects help abstract away exactly this issue; two distinct callback chains, one for success case and another for failure case, are created, each holding ["references to all of the callbacks registered for an event"](http://aosabook.org/en/twisted.html). This means that the Deferred object can be more easily passed around as a single object in code that holds both execution paths determined by the callback chains it is referencing.

In the Twisted code repository, the Deferred abstraction is implemented in the `defer.py` file in source code. The path to this file is: `\twisted\src\twisted\internet\defer.py`. From here, many other Twisted services instantiate Deferred objects that are modelled by the class description in this file. The Deferred object contains many moving parts in its state to fulfill operations around callback chains. The abstraction contains a flag used to determine when a callback or errback is called for the first time, and other ones to mark the end of recursive executon of a callback chain, and to signal that a callback will eventually be called and its result should be discarded. It also has the ability to reference the (possible) result of another Deferred instance it is waiting for, and can count how many calls have been made on the instance of the Deferred object. With these elements in its state, the Deferred object abstraction can maintain entire callback (success case) and errback (fail case) chains for an executing process. They offer a large amount of modifiability in code, as abstraction instances, which reference all relevant callbacks, can be moved around much more easily than a complex callback chain. Deferreds are especially useful in asynchronous programming (such as event-driven programming that Twisted middleware enables) by allowing callbacks to execute sometime when a process is no longer busy, without forcing the application to use valuable resources during this waiting period. Deferred objects offer operations to add callbacks to the connected callback/errback chains, chain Deferred objects together, and run the entirety of the callback chains it is referenced to.

Deferred abstractions are widely used in Twisted middleware, specifically for the implementation of asynchronous event-driven programming. Callbacks are essential to create an asynchronous environment, by only executing once a thread becomes available and data requested for the function can be processed. Deferred objects are used in all instances of asynchronous programming when using the Twisted middleware, as they abstract away the complex callback chains that are necessary to follow the event-driven model. Networking applications commonly use Deferred objects, as in these types of applications, there are often many processes waiting on responses (events) and are blocked until they can be handled. Also, online games typically make use of the event-driven model because of the large amount of events to be handled, and so Deferred abstractions can simplify the complex callback chains that are a consequence of event handling.

# Part 2: Comparison of Abstractions Between Systems
### Node.js

The Node.js JavaScript engine does not directly implement its own version of a callback chain management system or abstraction. Instead, Node leverages the JavaScript-native abstraction of a [Promise](https://nodejs.dev/learn/understanding-javascript-promises). Promises perform very similarly to the Deferred object, in that they are an abstraction of callback chains that are used to defer the result of a computation until later, specifically creating a "promise" that a value will be returned in the future. They abstract complex callback chains by creating two execution paths - resolve (success) and reject (error) - that act as handlers based on the returned data that the Promise receives. More recently, JavaScript - and therefore Node.js programming methods - has evolved to make use of `async/await` functions, which are a simplified way to handle asynchronous programming. Async functions are abstractions that are built on top of the Promise abstraction, abstracting at a higher level but relying on Promises to do so. Promises are therefore a key abstraction in Node.js and essential to modern-day asynchronous JavaScript.

Promises are implemented as interfaces in a JavaScript library that are used within Node.js (as they are not strictly Node architecture). Therefore, the implementation of Promises can be found in a package, created in TypeScript, by Microsoft Corporation: `usr/lib/node_modules/typescript/lib/lib.es2021.promise.d.ts`. The Promise abstraction is very similar to Twisted's Deferred object; both abstractions simplify callback chain management by providing two ordered execution paths, and allowing chaining between object instances. They both solve the problem of unmanageable code around complex callbacks that come with asynchronous programming. Operations supported by both objects are similar - queueing and dequeuing callback references, instance chaining capabilities, and fulfilling the end value that a callback returns. JavaScript's Promise does differ from the Twisted Deferred abstraction in a few ways. One key point about how the Promise object works is its dependency on a Resolver. A Resolver for a Promise allows an instance of a Promise to be resolved with a given value. The Promise abstractions encorporates methods to perform this operation, while Twisted Deferred objects essentially implemented a Resolver into the Deferred architecture. So, the Deferred object is more similar to the combination of the JS Promise and Resolver pair, in that it appears in the Deferred architecture that values from Deferred objects are carried along and need not be resolved directly. Because both Deferred and Promise abstractions are so similar, their benefits are identical. They benefit the understanding and handling of asynchronous programming and callbacks, which is a large usability benefit for a developer. Lastly, both abstractions carry entire callback chains, which helps with moving callback chains around in code.

### Flask

Flask microframework abstraction does not encorporate a callback handler abstraction in the same way that Twisted's Deferred object does. Instead, Flask leverages Python 3.5+'s async & await functionality, along with a few extra operations for deferred request callbacks. Async/await is Python's way of adding asynchronous capabilities to what looks like synchronous code at first glance. Functions that are declared as aynchronous are called 'coroutines', and return what are called 'coroutine objects' - objects that act like JS Promises, in that they guarantee a return value sometime in the future. To call the asynchronous function in code, the 'await' keyword is used, which passes execution back to the event loop, effectively suspending the coroutine. Async/await allows resources to be used elsewhere in an application, and only returns to the coroutine scope once the awaited-on result is returned later on, making asynchronous programming possible. Additionally, Flask implements their own operations to help manage callbacks - `before_request()` and `after_request()`. These functions abstract the idea of callbacks by offerring dedicated control over when a developer wants some code to execute - either before or after some request is made. Because these functions are separated from the request handler, it is visually easier to understand what will be executed around the time that the request is made. Neither of these functionalities inhibit or replace the use of callbacks in Flask, but instead encorporate them all to offer developers a variety of tools for their builds.

Async/await is built as native functionality from the developers of Python in the [asyncio library](https://github.com/python/cpython/tree/main/Lib/asyncio). The declaration of the `async` and `await` keywords specifically could not be found in an exact file, but it is that library that contains a large portion of declarations and functionality around Python's asynchronous programming. Flask's callback-abstracting operations, `before_request()` and `after_request()`, are implemented in the Flask class object through the inheritance of the Scaffold class, found [here](https://github.com/pallets/flask/blob/main/src/flask/scaffold.py). Python's async/await combined with Flask's callback operations are together very different from Twisted's Deferred object which elegantly handles complex callback chains. Async/await keywords allow programmers to create an asynchronous environment where callbacks can be returned later, but provide no means of easily handling callback chains, as there is no abstraction towards managing callbacks. Flask's callback operations provide a cleaner way to define what comes before or after a request, but fails to make it as reusable and moveable in code as Twisted does, where Deferred object instances can be passed around as a single object. Typical scenarios where an event-driven model is involved becomes more difficult to handle, as complex callback chains are not abstracted from the developer, who has to deal with nested complexity. The benefits to the combination of async/await and callback operations is that Flask leaves multiple options open to the developer for programming an asynchronous application, and offers a solution that cleans up the code around callbacks, but without really making them easier to work with.