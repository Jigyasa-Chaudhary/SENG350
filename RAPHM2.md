# Milestone 2: Reverse Engineering Abstractions
Name: Raphael Bassot
Course: SENG350 - Software Architecture
Group: #2

# Part 1: Abstractions in the Reference System - Twisted
### Abstraction: Deferred Objects
One important abstraction that Twisted makes use of is the concept of a *Deferred* object to help organize the consequences that follow event-driven programming. A Deferred object is a type of abstraction that is in essence ["a promise that a function [returning a Deferred object] will return at some point"](http://aosabook.org/en/twisted.html). This abstraction's purpose revolves around the nature of callback functions - executables that are passed as arguments to a parent function that typically execute after the parent has completed its work. In event-driven programming, callbacks execute asynchronously, which means they can execute sometime later on, independently of other running code. The implementation of asynchronous callbacks is what allows Twisted to follow event-driven design. Event-driven programming involves a continuously-executing event loop that detects event triggers (termination). Completed events trigger callback functions, which describe how the event that just ended in an application should be handled (post-completion behaviour). Multiple events completing can result in a chain of callbacks being called, which can become confusing to follow for the developer. Deferred objects help abstract away exactly this issue; two distinct callback chains, one for success case and another for failure case, are created, each holding ["references to all of the callbacks registered for an event"](http://aosabook.org/en/twisted.html). This means that the Deferred object can be more easily passed around as a single object in code that holds both execution paths determined by the callback chains it is referencing.

In the Twisted code repository, the Deferred abstraction is implemented in the `defer.py` file in source code. The path to this file is: `\twisted\src\twisted\internet\defer.py`. From here, many other Twisted services instantiate Deferred objects that are modelled by the class description in this file. The Deferred object contains many moving parts in its state to fulfill operations around callback chains. The abstraction contains a flag used to determine when a callback or errback is called for the first time, and other ones to mark the end of recursive executon of a callback chain, and to signal that a callback will eventually be called and its result should be discarded. It also has the ability to reference the (possible) result of another Deferred instance it is waiting for, and can count how many calls have been made on the instance of the Deferred object. With these elements in its state, the Deferred object abstraction can maintain entire callback (success case) and errback (fail case) chains for an executing process. They offer a large amount of modifiability in code, as abstraction instances, which reference all relevant callbacks, can be moved around much more easily than a complex callback chain. Deferreds are especially useful in asynchronous programming (such as event-driven programming that Twisted middleware enables) by allowing callbacks to execute sometime when a process is no longer busy, without forcing the application to use valuable resources during this waiting period. Deferred objects offer operations to add callbacks to the connected callback/errback chains, chain Deferred objects together, and run the entirety of the callback chains it is referenced to.

Deferred abstractions are widely used in Twisted middleware, specifically for the implementation of asynchronous event-driven programming. Callbacks are essential to create an asynchronous environment, by only executing once a thread becomes available and data requested for the function can be processed. Deferred objects are used in all instances of asynchronous programming when using the Twisted middleware, as they abstract away the complex callback chains that are necessary to follow the event-driven model. Networking applications commonly use Deferred objects, as in these types of applications, there are often many processes waiting on responses (events) and are blocked until they can be handled. Also, online games typically make use of the event-driven model because of the large amount of events to be handled, and so Deferred abstractions can simplify the complex callback chains that are a consequence of event handling.

# Part 2: Comparison of Abstractions Between Systems
### Node.js

### Flask
