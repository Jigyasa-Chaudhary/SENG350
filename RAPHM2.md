# Milestone 2: Reverse Engineering Abstractions
Name: Raphael Bassot
Course: SENG350 - Software Architecture
Group: #2

# Part 1: Abstractions in the Reference System - Twisted
### Abstraction: Deferred Objects
One important abstraction that Twisted makes use of is the concept of a *Deferred* object to help organize the consequences that follow event-driven programming. A Deferred object is a type of abstraction that is in essence ["a promise that a function [returning a Deferred object] will return at some point"](http://aosabook.org/en/twisted.html). This abstraction's purpose revolves around the nature of callback functions - executables that are passed as arguments to a parent function that typically execute after the parent has completed its work. In event-driven programming, callbacks execute asynchronously, which means they can execute sometime later on, independently of other running code. The implementation of asynchronous callbacks is what allows Twisted to follow event-driven design. Event-driven programming involves a continuously-executing event loop that detects event triggers (termination). Completed events trigger callback functions, which describe how the event that just ended in an application should be handled (post-completion behaviour). Multiple events completing can result in a chain of callbacks being called, which can become confusing to follow for the developer. Deferred objects help abstract away exactly this issue; two distinct callback chains, one for success case and another for failure case, are created, each holding ["references to all of the callbacks registered for an event"](http://aosabook.org/en/twisted.html). This means that the Deferred object can be more easily passed around as a single object in code that holds both execution paths determined by the callback chains it is referencing.

In the Twisted code repository, the Deferred abstraction is implemented in the `defer.py` file in source code. The path to this file is: `\twisted\src\twisted\internet\defer.py`. From here, many other Twisted services instantiate Deferred objects that are modelled by the class description in this file. The Deferred object contains many moving parts in its state to fulfill operations around callback chains. The abstraction contains a flag used to determine when a callback or errback is called for the first time, and other ones to mark the end of recursive executon of a callback chain, and to signal that a callback will eventually be called and its result should be discarded. It also has the ability to reference the (possible) result of another Deferred instance it is waiting for, and can count how many calls have been made on the instance of the Deferred object. With these elements in its state, the Deferred object abstraction can maintain entire callback (success case) and errback (fail case) chains for an executing process. They offer a large amount of modifiability in code, as abstraction instances, which reference all relevant callbacks, can be moved around much more easily than a complex callback chain. Deferreds are especially useful in asynchronous programming (such as event-driven programming that Twisted middleware enables) by allowing callbacks to execute sometime when a process is no longer busy, without forcing the application to use valuable resources during this waiting period. Deferred objects offer operations to add callbacks to the connected callback/errback chains, chain Deferred objects together, and run the entirety of the callback chains it is referenced to.

Deferred abstractions are widely used in Twisted middleware, specifically for the implementation of asynchronous event-driven programming. Callbacks are essential to create an asynchronous environment, by only executing once a thread becomes available and data requested for the function can be processed. Deferred objects are used in all instances of asynchronous programming when using the Twisted middleware, as they abstract away the complex callback chains that are necessary to follow the event-driven model. Networking applications commonly use Deferred objects, as in these types of applications, there are often many processes waiting on responses (events) and are blocked until they can be handled. Also, online games typically make use of the event-driven model because of the large amount of events to be handled, and so Deferred abstractions can simplify the complex callback chains that are a consequence of event handling.

# Part 2: Comparison of Abstractions Between Systems
### Node.js

The Node.js JavaScript engine does not directly implement its own version of a callback chain management system or abstraction. Instead, Node leverages the JavaScript-native abstraction of a [Promise](https://nodejs.dev/learn/understanding-javascript-promises). Promises perform very similarly to the Deferred object, in that they are an abstraction of callback chains that are used to defer the result of a computation until later, specifically creating a "promise" that a value will be returned in the future. They abstract complex callback chains by creating two execution paths - resolve (success) and reject (error) - that act as handlers based on the returned data that the Promise receives. More recently, JavaScript - and therefore Node.js programming methods - has evolved to make use of `async/await` functions, which are a simplified way to handle asynchronous programming. Async functions are abstractions that are built on top of the Promise abstraction, abstracting at a higher level but relying on Promises to do so. Promises are therefore a key abstraction in Node.js and essential to modern-day asynchronous JavaScript.

Promises are implemented as interfaces in a JavaScript library that are used within Node.js (as they are not strictly Node architecture). Therefore, the implementation of Promises can be found in a package, created in TypeScript, by Microsoft Corporation: `usr/lib/node_modules/typescript/lib/lib.es2021.promise.d.ts`. The Promise abstraction is very similar to Twisted's Deferred object; both abstractions simplify callback chain management by providing two ordered execution paths, and allowing chaining between object instances. They both solve the problem of unmanageable code around complex callbacks that come with asynchronous programming. Operations supported by both objects are similar - queueing and dequeuing callback references, instance chaining capabilities, and fulfilling the end value that a callback returns. JavaScript's Promise does differ from the Twisted Deferred abstraction in a few ways. One key point about how the Promise object works is its dependency on a Resolver. A Resolver for a Promise allows an instance of a Promise to be resolved with a given value. The Promise abstractions encorporates methods to perform this operation, while Twisted Deferred objects essentially implemented a Resolver into the Deferred architecture. So, the Deferred object is more similar to the combination of the JS Promise and Resolver pair, in that it appears in the Deferred architecture that values from Deferred objects are carried along and need not be resolved directly. Because both Deferred and Promise abstractions are so similar, their benefits are identical. They benefit the understanding and handling of asynchronous programming and callbacks, which is a large usability benefit for a developer. Lastly, both abstractions carry entire callback chains, which helps with moving callback chains around in code.

### Flask

Flask microservices abstraction ...